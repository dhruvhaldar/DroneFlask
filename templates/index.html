<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>6DOF Quadcopter Control</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Custom Glassmorphism */
      .glass {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
      body {
        margin: 0;
        overflow: hidden;
        background-color: #1a202c;
      }
      #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
      }
      #ui-layer {
        position: relative;
        z-index: 10;
        pointer-events: none;
      }
      .interactive {
        pointer-events: auto;
      }
    </style>
  </head>
  <body class="text-white">
    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col h-screen p-6 justify-between">
      <!-- Header -->
      <div
        class="glass p-4 rounded-xl max-w-md interactive animate-fade-in-down"
      >
        <h1
          class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500"
        >
          Areo Quadcopter Sim
        </h1>
        <p class="text-xs text-gray-300 mt-1">
          Status: <span id="status-text" class="text-green-400">Connected</span>
        </p>
      </div>

      <!-- Telemetry Panel -->
      <div
        class="absolute top-6 right-6 glass p-4 rounded-xl w-64 interactive space-y-2"
      >
        <h2
          class="text-sm font-semibold text-gray-400 uppercase tracking-wider"
        >
          Telemetry
        </h2>
        <div class="flex justify-between">
          <span>Alt (Z):</span>
          <span id="val-z" class="font-mono text-blue-300">0.00</span> m
        </div>
        <div class="flex justify-between">
          <span>Roll:</span>
          <span id="val-phi" class="font-mono text-purple-300">0.00</span> rad
        </div>
        <div class="flex justify-between">
          <span>Pitch:</span>
          <span id="val-theta" class="font-mono text-purple-300">0.00</span> rad
        </div>
        <div class="flex justify-between">
          <span>Yaw:</span>
          <span id="val-psi" class="font-mono text-purple-300">0.00</span> rad
        </div>
      </div>

      <!-- Controls Help -->
      <div class="self-center glass px-6 py-3 rounded-full mb-8 interactive">
        <kbd class="bg-gray-700 px-2 py-1 rounded text-xs">W</kbd>
        <kbd class="bg-gray-700 px-2 py-1 rounded text-xs">S</kbd> Thrust
        <span class="mx-2">|</span>
        <kbd class="bg-gray-700 px-2 py-1 rounded text-xs">↑</kbd>
        <kbd class="bg-gray-700 px-2 py-1 rounded text-xs">↓</kbd> Pitch
        <span class="mx-2">|</span>
        <kbd class="bg-gray-700 px-2 py-1 rounded text-xs">←</kbd>
        <kbd class="bg-gray-700 px-2 py-1 rounded text-xs">→</kbd> Roll
        <span class="mx-2">|</span>
        <kbd class="bg-gray-700 px-2 py-1 rounded text-xs">A</kbd>
        <kbd class="bg-gray-700 px-2 py-1 rounded text-xs">D</kbd> Yaw
      </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
      // --- 1. Socket IO ---
      const socket = io();
      let droneState = { x: 0, y: 0, z: 0, phi: 0, theta: 0, psi: 0 };

      socket.on("connect", () => {
        document.getElementById("status-text").innerText = "Online";
        document.getElementById("status-text").className = "text-green-400";
      });

      socket.on("state", (msg) => {
        // msg.data = [x,y,z, vx,vy,vz, phi,theta,psi, p,q,r]
        const d = msg.data;
        if (!d) return;
        droneState.x = d[0];
        droneState.y = d[1];
        droneState.z = d[2];
        droneState.phi = d[6]; // Roll (x axis rot)
        droneState.theta = d[7]; // Pitch (y axis rot)
        droneState.psi = d[8]; // Yaw (z axis rot)

        updateHUD(droneState);
      });

      function updateHUD(s) {
        document.getElementById("val-z").innerText = (-s.z).toFixed(2); // Sim Z is down? Usually NED. Let's check visualization.
        // If NED: Z positive down. Altitude = -Z.
        // visualizer checks.
        document.getElementById("val-phi").innerText = s.phi.toFixed(3);
        document.getElementById("val-theta").innerText = s.theta.toFixed(3);
        document.getElementById("val-psi").innerText = s.psi.toFixed(3);
      }

      // --- 2. Controls ---
      const keys = {
        w: 0,
        s: 0,
        a: 0,
        d: 0,
        ArrowUp: 0,
        ArrowDown: 0,
        ArrowLeft: 0,
        ArrowRight: 0,
      };
      let cmd = { thrust: 0, roll: 0, pitch: 0, yaw: 0 }; // Normalized or Ref

      window.addEventListener("keydown", (e) => {
        keys[e.key] = 1;
        updateCmd();
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key] = 0;
        updateCmd();
      });

      function updateCmd() {
        // Logic
        // Thrust: W(+), S(-) (Accumulate? Or Direct?)
        // Interactive usually means Direct or Rate.
        // Let's do simple increment for Thrust (Throttle)

        // Roll/Pitch: Arrows (Direct, spring back?)
        const rollMax = 0.5; // rad (~30 deg)
        const pitchMax = 0.5;

        // Roll: Left/Right
        let r = 0;
        if (keys.ArrowLeft) r = -rollMax;
        if (keys.ArrowRight) r = rollMax;

        // Pitch: Up/Down
        let p = 0;
        if (keys.ArrowUp) p = pitchMax; // Pitch up? Or forward?
        // Usually Forward (Stick Up) -> Pitch Down (Nose Down) -> Move Forward
        // Let's map Up -> Pitch Down (-theta)
        if (keys.ArrowDown) p = -pitchMax;

        // Yaw: A/D (Rate)
        let y = 0;
        if (keys.a) y = -1.0;
        if (keys.d) y = 1.0;

        // Thrust:
        // We need a persistent throttle variable
        if (keys.w) throttle += 0.05;
        if (keys.s) throttle -= 0.05;
        throttle = Math.max(0, Math.min(1, throttle));

        cmd.thrust = throttle;
        cmd.roll = r;
        cmd.pitch = p; // Direct angle command
        cmd.yaw = y; // Yaw Rate command

        socket.emit("control", cmd);
      }

      let throttle = 0.0; // 0 to 1

      // --- 3. Three.js Visualization ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a202c);
      scene.fog = new THREE.Fog(0x1a202c, 10, 50);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document
        .getElementById("canvas-container")
        .appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(5, 10, 7);
      scene.add(dirLight);

      // Grid
      const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
      scene.add(gridHelper);

      // Quadcopter Model (Simple Group)
      const drone = new THREE.Group();

      // Arms
      const armGeo = new THREE.BoxGeometry(0.5, 0.05, 0.05);
      const armMat = new THREE.MeshStandardMaterial({ color: 0x3b82f6 }); // Blue-500
      const arm1 = new THREE.Mesh(armGeo, armMat);
      const arm2 = new THREE.Mesh(armGeo, armMat);
      arm2.rotation.y = Math.PI / 2;
      drone.add(arm1);
      drone.add(arm2);

      // Center Body
      const bodyGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 16);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0xef4444 }); // Red-500
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      drone.add(body);

      // Props (Visual only)
      const propGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.01, 8);
      const propMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.5,
      });
      const props = [];
      const offsets = [
        [0.25, 0],
        [-0.25, 0],
        [0, 0.25],
        [0, -0.25],
      ];
      offsets.forEach((pos) => {
        const p = new THREE.Mesh(propGeo, propMat);
        p.position.set(pos[0], 0.05, pos[1]);
        drone.add(p);
        props.push(p);
      });

      scene.add(drone);

      // Camera Logic
      camera.position.set(0, 2, 5);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Animation Loop
      function animate() {
        requestAnimationFrame(animate);

        // Update Drone Transform using latest Server State
        // Coordinate System Mapping:
        // Sim: NED (x=North, y=East, z=Down)? Or standard?
        // Quad Viz usually: X=Forward, Y=Left, Z=Up.
        // If Sim is standard aerospace (z down), we map:
        // ThreeJS: Y is Up.
        // Sim x -> Three -z (Forward)
        // Sim y -> Three x (Right)
        // Sim z -> Three y (Up, inverted)

        // Let's assume Sim is: Z UP (for ease, code seemed so)
        // visualization.py used: p.z IS up.
        // So direct mapping: x->x, y->-z(forward in three?), z->y(up in three)
        // Matplotlib 3D: Z is Up. X/Y ground.

        // ThreeJS default: Y Up. -Z Forward. X Right.
        // Mapping:
        // Sim X -> Three ?
        // Let's just try direct mapping first:
        drone.position.x = droneState.x;
        drone.position.z = droneState.y; // Y in sim is usually lateral
        drone.position.y = droneState.z; // Z in sim is Up

        // Rotation (Euler XYZ?)
        // ThreeJS Euler is usually XYZ.
        drone.rotation.x = droneState.phi;
        drone.rotation.z = droneState.theta; // Pitch often Y in Three?
        drone.rotation.y = droneState.psi;

        // Spin props
        props.forEach((p) => (p.rotation.y += 0.5));

        // Camera follow
        // camera.lookAt(drone.position);

        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Handle Resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
